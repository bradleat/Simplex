// Generated by CoffeeScript 1.7.1
(function() {
  var jsepAST;

  exports.jsepAST = jsepAST = (function() {
    function jsepAST(AST) {
      this.string = '';
      this.toString(AST);
    }

    jsepAST.prototype.toString = function(AST) {
      if (AST.type === 'Literal') {
        return this._foundLiteral(AST);
      } else if (AST.type === 'Identifier') {
        return this._foundIdentifier(AST);
      } else if (AST.type === 'Compound') {
        return this._foundCompound(AST);
      } else if (AST.type === 'BinaryExpression') {
        return this._foundBinaryExpression(AST);
      } else {
        throw new Error("AST type not in ['Compound', 'BinaryExpression', 'Identifier', 'Literal']. Tip: 12x should be written as 12(x)");
      }
    };

    jsepAST.prototype._foundLiteral = function(AST) {
      return this.string += AST.value;
    };

    jsepAST.prototype._foundIdentifier = function(AST) {
      return this.string += AST.name;
    };

    jsepAST.prototype._foundCompound = function(AST) {
      var expression, _i, _len, _ref, _results;
      _ref = AST.body;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        expression = _ref[_i];
        _results.push(this.toString(expression));
      }
      return _results;
    };

    jsepAST.prototype._foundBinaryExpression = function(AST) {
      var _ref;
      if ((_ref = AST.operator) === '+' || _ref === '-') {
        this.toString(AST.left);
        this.string += " " + AST.operator + " ";
        return this.toString(AST.right);
      } else {
        throw new Error("Only expressions in ['+', '-'] are supported. Tip: 12*x should be written as 12(x)");
      }
    };

    return jsepAST;

  })();

  exports.linearMatrix = window.linearMatrix = (function() {
    function linearMatrix(linearArr) {

      /**
        equations of linearArr should look like:
        {
          expr: STRING
          op: #in ['lte', 'gte', 'e']
          res: STRING or Number
        }
        if the result is a string, op must equal 'e'
        if the result is a number op must equal 'lte' or 'gte'
      
      *
       */
      var equation, i, _i, _len;
      this.matrix = [];
      for (i = _i = 0, _len = linearArr.length; _i < _len; i = ++_i) {
        equation = linearArr[i];
        this.parse(equation, i, true);
      }
    }

    linearMatrix.prototype.parse = function(equation, i, toMatrix) {
      var NumValidate, NumVar, StrValidate, mode, negative, part, res, _i, _len, _ref, _ref1;
      if (toMatrix == null) {
        toMatrix = false;
      }
      NumVar = /^(\d+)?([A-z]+)$/;
      StrValidate = /^[A-z]+$/;
      NumValidate = /^[\d]+$/;
      this.matrix.push({});
      negative = false;
      if (equation.op === 'e' && StrValidate.test(equation.res)) {
        mode = 'objective';
      } else if (((_ref = equation.op) === 'lte' || _ref === 'gte') && NumValidate.test(equation.res)) {
        mode = 'constraint';
      }
      _ref1 = equation.expr.split(' ');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        part = _ref1[_i];
        res = NumVar.exec(part);
        if (res == null) {
          if (part === '-') {
            negative = true;
          }
          if (part === '+') {
            negative = false;
          }
        } else {
          if ((res[1] != null) && (res[2] != null)) {
            if (mode === 'objective') {
              res[1] = -res[1];
            }
            this.matrix[i][res[2]] = parseFloat(res[1]);
          } else if (res[1] != null) {
            if (mode === 'constraint') {
              if (negative) {
                equation.res = +res[1];
              } else {
                equation.res = -res[1];
              }
            } else if (mode === 'objective') {
              throw new Error('objective function not simplified!');
            }
          } else if (res[2] != null) {
            if (negative) {
              this.matrix[i][res[2]] = -1;
            } else {
              this.matrix[i][res[2]] = 1;
              this.matrix[i][res[2]] = 1;
            }
          }
        }
      }
      if (mode === 'constraint') {
        if (equation.op === 'lte') {
          this.matrix[i]["$0" + res[2]] = 1;
        } else if (equation.op === 'gte') {
          this.matrix[i]["$0" + res[2]] = -1;
        }
        return this.matrix[i]['constraint'] = parseInt(equation.res);
      } else if (mode === 'objective') {
        return this.matrix[i][equation.res] = 1;
      }
    };

    return linearMatrix;

  })();

}).call(this);
