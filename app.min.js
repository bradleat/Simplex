(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/**

1. Goal: Maximize
2: Objective: 2x + y = P
3: x + y >=2
4: y >= 0
5: x >= 0

----->>
x | y | s1 | s2 | s3 | P | C
1   1   -1    0    0   0   2
1   0    0    -1   0   0   0
0   1    0    0    -1  0   0
-2 -1   0     0    0   1   0


select pivot column x, because -2 is most negative

for each row: divide C by the pivot colums entry for that row

select smallest as the pivot row

divide by receprocal

use this row to make the pivot colums entry 0 for each other row

select another pivot unless no negative indicators (all but P,C)





*
 */

(function() {
  var SimplexFormer, SimplexSolver;

  SimplexFormer = require('./input');

  SimplexSolver = require('./solver');

  window.Simplex = (function() {
    function Simplex(div) {
      var button, input;
      input = new SimplexFormer("" + div + "Form");
      button = "" + div + "Button";
      $("#" + button).text('Start Solve');
      $("#" + button).click(function() {
        var solver;
        if (input.outputMatrix != null) {
          $("#" + button).off();
          console.log(input.outputMatrix);
          console.log(div);
          solver = new SimplexSolver(input.outputMatrix, div);
          return $("#" + button).text('Step Simplex');
        }
      });
    }

    return Simplex;

  })();


  /**
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  To define a simplex matrix is defined
  the first n columns of a row are for the variables
  the next n colums of a row are for slack variables
  the next column is for the P of the objective function
  the next column is for the constraint
  
  to make a solver and attach it to a div (with a unique ID!) do as follows:
  
  mySolver = new SimplexSolver(myMatrix, "myDivID");
  
  
    
  *
   */

}).call(this);

},{"./input":2,"./solver":4}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var SimplexFormer, jsepAST, linearMatrix,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jsepAST = require('./parsers').jsepAST;

  linearMatrix = require('./parsers').linearMatrix;

  module.exports = SimplexFormer = (function() {
    function SimplexFormer(div) {
      this.div = div;
      this.outputMatrix = null;
      this.FormContext = {
        objFuncMessage: cjs.constraint(false),
        newConstraintFuncMessage: cjs.constraint(false),
        constraint: cjs.array([]),
        matrix: cjs.array([]),
        order: cjs.array([])
      };
      window.debugContext = this.FormContext;
      $((function(_this) {
        return function() {
          $("#" + _this.div).html(cjs.createTemplate($('#SimplexForm'), _this.FormContext));
          $("#new-constraint-add").on('click', function() {
            var res, resObjective;
            res = _this.validate(_this.FormContext.newConstraintFunc.get(), 'constraint');
            if (res) {
              _this.FormContext.constraint.push(res);
              resObjective = _this.validate(_this.FormContext.objFunc.get(), 'objective');
              return _this.toMatrix(resObjective, _this.FormContext.constraint.toArray());
            }
          });
          return cjs.liven(function() {
            _this.validate(_this.FormContext.newConstraintFunc.get(), 'constraint');
            return _this.validate(_this.FormContext.objFunc.get(), 'objective');
          });
        };
      })(this));
    }

    SimplexFormer.prototype.toMatrix = function(objective, constraints) {
      var col, matrix, matrixRow, objectiveName, order, preForm, row, varName, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      if (objective && typeof objective !== 'string' && constraints.length !== 0) {
        objectiveName = objective.res;
        preForm = new linearMatrix([objective]);
        objective = preForm.matrix[0];
        order = [];
        for (varName in objective) {
          if (varName !== objectiveName) {
            order.push(varName);
          }
        }
        preForm = new linearMatrix(constraints);
        constraints = preForm.matrix;
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          row = constraints[_i];
          for (varName in row) {
            if (__indexOf.call(order, varName) < 0 && varName[0] !== '$' && varName !== 'constraint') {
              order.push(varName);
            }
          }
        }
        for (_j = 0, _len1 = constraints.length; _j < _len1; _j++) {
          row = constraints[_j];
          for (varName in row) {
            if (varName[0] === '$' && __indexOf.call(order, varName) < 0) {
              order.push(varName);
            }
          }
        }
        order.push(objectiveName);
        order.push('constraint');
        constraints.push(objective);
        matrix = [];
        for (_k = 0, _len2 = constraints.length; _k < _len2; _k++) {
          row = constraints[_k];
          matrixRow = [];
          for (_l = 0, _len3 = order.length; _l < _len3; _l++) {
            col = order[_l];
            if (row[col] == null) {
              row[col] = 0;
            }
            matrixRow.push(row[col]);
          }
          matrix.push(matrixRow);
        }
        this.FormContext.order.setValue(order);
        this.FormContext.matrix.setValue(matrix);
        return this.outputMatrix = matrix;
      }
    };

    SimplexFormer.prototype.validate = function(toValidate, type) {
      var e, parse, set, validateObj;
      if (type === 'constraint') {
        set = 'newConstraintFuncMessage';
      } else if (type === 'objective') {
        set = 'objFuncMessage';
      }
      if (set != null) {
        validateObj = {
          val: toValidate,
          e: null
        };
        try {
          return jsep(validateObj.val);
        } catch (_error) {
          e = _error;
          return validateObj.e = e.dedscription;
        } finally {
          if (validateObj.e != null) {
            this.FormContext[set].set(validateObj.e);
          } else {
            try {
              parse = new jsepAST(jsep(validateObj.val));
            } catch (_error) {
              e = _error;
              validateObj.e = e.message;
            } finally {
              if (validateObj.e != null) {
                this.FormContext[set].set(validateObj.e);
              } else {
                if (type === 'objective') {
                  if (/^[A-z]+$/.test(this.FormContext.objVar.get())) {
                    this.FormContext[set].set(false);
                    return {
                      expr: parse.string,
                      op: "e",
                      res: this.FormContext.objVar.get()
                    };
                  } else {
                    this.FormContext[set].set('Objective value must a variable name!');
                    return false;
                  }
                } else if (type === 'constraint') {
                  if (/^[\d]+$/.test(this.FormContext.newConstraintVal.get())) {
                    this.FormContext[set].set(false);
                    return {
                      expr: parse.string,
                      op: $('#newConstraintOp').children(':selected').first().val(),
                      res: this.FormContext.newConstraintVal.get()
                    };
                  } else {
                    this.FormContext[set].set('Constraint value must be a number!');
                    return false;
                  }
                } else {
                  this.FormContext[set].set('Something went wrong');
                  return false;
                }
              }
            }
          }
        }
      }
    };

    return SimplexFormer;

  })();

}).call(this);

},{"./parsers":3}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var jsepAST;

  exports.jsepAST = jsepAST = (function() {
    function jsepAST(AST) {
      this.string = '';
      this.toString(AST);
    }

    jsepAST.prototype.toString = function(AST) {
      if (AST.type === 'Literal') {
        return this._foundLiteral(AST);
      } else if (AST.type === 'Identifier') {
        return this._foundIdentifier(AST);
      } else if (AST.type === 'Compound') {
        return this._foundCompound(AST);
      } else if (AST.type === 'BinaryExpression') {
        return this._foundBinaryExpression(AST);
      } else {
        throw new Error("AST type not in ['Compound', 'BinaryExpression', 'Identifier', 'Literal']. Tip: 12x should be written as 12(x)");
      }
    };

    jsepAST.prototype._foundLiteral = function(AST) {
      return this.string += AST.value;
    };

    jsepAST.prototype._foundIdentifier = function(AST) {
      return this.string += AST.name;
    };

    jsepAST.prototype._foundCompound = function(AST) {
      var expression, _i, _len, _ref, _results;
      _ref = AST.body;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        expression = _ref[_i];
        _results.push(this.toString(expression));
      }
      return _results;
    };

    jsepAST.prototype._foundBinaryExpression = function(AST) {
      var _ref;
      if ((_ref = AST.operator) === '+' || _ref === '-') {
        this.toString(AST.left);
        this.string += " " + AST.operator + " ";
        return this.toString(AST.right);
      } else {
        throw new Error("Only expressions in ['+', '-'] are supported. Tip: 12*x should be written as 12(x)");
      }
    };

    return jsepAST;

  })();

  exports.linearMatrix = window.linearMatrix = (function() {
    function linearMatrix(linearArr) {

      /**
        equations of linearArr should look like:
        {
          expr: STRING
          op: #in ['lte', 'gte', 'e']
          res: STRING or Number
        }
        if the result is a string, op must equal 'e'
        if the result is a number op must equal 'lte' or 'gte'
      
      *
       */
      var equation, i, _i, _len;
      this.matrix = [];
      for (i = _i = 0, _len = linearArr.length; _i < _len; i = ++_i) {
        equation = linearArr[i];
        this.parse(equation, i, true);
      }
    }

    linearMatrix.prototype.parse = function(equation, i, toMatrix) {
      var NumValidate, NumVar, StrValidate, mode, negative, part, res, _i, _len, _ref, _ref1;
      if (toMatrix == null) {
        toMatrix = false;
      }
      NumVar = /^(\d+)?([A-z]+)$/;
      StrValidate = /^[A-z]+$/;
      NumValidate = /^[\d]+$/;
      this.matrix.push({});
      negative = false;
      if (equation.op === 'e' && StrValidate.test(equation.res)) {
        mode = 'objective';
      } else if (((_ref = equation.op) === 'lte' || _ref === 'gte') && NumValidate.test(equation.res)) {
        mode = 'constraint';
      }
      _ref1 = equation.expr.split(' ');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        part = _ref1[_i];
        res = NumVar.exec(part);
        if (res == null) {
          if (part === '-') {
            negative = true;
          }
          if (part === '+') {
            negative = false;
          }
        } else {
          if ((res[1] != null) && (res[2] != null)) {
            if (mode === 'objective') {
              res[1] = -res[1];
            }
            this.matrix[i][res[2]] = parseFloat(res[1]);
          } else if (res[1] != null) {
            if (mode === 'constraint') {
              if (negative) {
                equation.res = +res[1];
              } else {
                equation.res = -res[1];
              }
            } else if (mode === 'objective') {
              throw new Error('objective function not simplified!');
            }
          } else if (res[2] != null) {
            if (negative) {
              this.matrix[i][res[2]] = -1;
            } else {
              this.matrix[i][res[2]] = 1;
              this.matrix[i][res[2]] = 1;
            }
          }
        }
      }
      if (mode === 'constraint') {
        if (equation.op === 'lte') {
          this.matrix[i]["$0" + res[2]] = 1;
        } else if (equation.op === 'gte') {
          this.matrix[i]["$0" + res[2]] = -1;
        }
        return this.matrix[i]['constraint'] = parseInt(equation.res);
      } else if (mode === 'objective') {
        return this.matrix[i][equation.res] = 1;
      }
    };

    return linearMatrix;

  })();

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = window.SimplexSolver = (function() {
    function SimplexSolver(matrix, div) {
      this.matrix = matrix;

      /**
        matrix is an arr of arr
        arr[0] returns the first row
        arr[0][0] returns the first elem in first row
      *
       */
      this.pivotCol = false;
      this.pivotRow = false;
      this.rowCount = this.matrix.length;
      this.colCount = this.matrix[0].length;
      this.indicatorRow = this.rowCount - 1;
      this.finshed = false;
      this.steps = ['selectPivot', 'selectPivotRow', 'normalizePivotRow', 'reducePivotColum'];
      this.stepCount = 0;
      this.start = true;
      if (div != null) {
        this.output = div;
        $("#" + div + "Button").on("click", (function(_this) {
          return function() {
            return _this.step();
          };
        })(this));
      }
    }

    SimplexSolver.prototype.print = function() {
      var i, row, _i, _len, _ref;
      $("#" + this.output).append("<pre>");
      _ref = this.matrix;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        row = _ref[i];
        $("#" + this.output).append("" + (JSON.stringify(this.matrix[i])) + "<br/>");
      }
      $("#" + this.output).append("</pre>");
      $("#" + this.output).append("PivotCol: " + this.pivotCol + "<br /> PivotRow: " + this.pivotRow + "<br /> Finshed: " + this.finshed + "</p>");
      $("#" + this.output).append("-----------------");
      if (!this.finshed) {
        return $("#" + this.output).append("<p> Step " + this.steps[this.stepCount] + ":\n </p><p>");
      }
    };

    SimplexSolver.prototype.selectPivot = function() {
      var elem, i, mostNegative, pivotCol, _i, _len, _ref;
      if (this.start) {
        this.pivotCol = 0;
        this.start = false;
        return;
      }
      mostNegative = Infinity;
      pivotCol = null;
      _ref = this.matrix[this.indicatorRow];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        elem = _ref[i];
        if (i < this.colCount - 2) {
          if (elem < mostNegative) {
            mostNegative = elem;
            pivotCol = i;
          }
        }
      }
      if (mostNegative < 0) {
        return this.pivotCol = pivotCol;
      } else {
        this.finshed = true;
        console.log(this.matrix);
        $("#" + this.output + "Button").text('Finshed');
        return $("#" + this.output + "Button").off();
      }
    };

    SimplexSolver.prototype.selectPivotRow = function() {
      var i, pivotRow, row, smallest, _i, _len, _ref;
      smallest = Infinity;
      pivotRow = null;
      _ref = this.matrix;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        row = _ref[i];
        if (i < this.rowCount - 1) {
          if (row[this.colCount - 1] / row[this.pivotCol] > 0) {
            if (row[this.colCount - 1] / row[this.pivotCol] < smallest) {
              smallest = row[this.colCount - 1] / row[this.pivotCol];
              pivotRow = i;
            }
          }
        }
      }
      this.pivotRow = pivotRow;
      if (this.pivotRow === null) {
        return this.finshed = true;
      }
    };

    SimplexSolver.prototype.normalizePivotRow = function() {
      var elem, i, receprocal, _i, _len, _ref, _results;
      receprocal = 1 / this.matrix[this.pivotRow][this.pivotCol];
      _ref = this.matrix[this.pivotRow];
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        elem = _ref[i];
        _results.push(this.matrix[this.pivotRow][i] = elem * receprocal);
      }
      return _results;
    };

    SimplexSolver.prototype.reducePivotColum = function() {
      var elem, i, j, multible, row, _i, _len, _ref, _results;
      _ref = this.matrix;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        row = _ref[i];
        if (!(i !== this.pivotRow)) {
          continue;
        }
        multible = this.matrix[i][this.pivotCol] / this.matrix[this.pivotRow][this.pivotCol];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = this.matrix[i];
          _results1 = [];
          for (j = _j = 0, _len1 = _ref1.length; _j < _len1; j = ++_j) {
            elem = _ref1[j];
            _results1.push(this.matrix[i][j] = elem - multible * this.matrix[this.pivotRow][j]);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    SimplexSolver.prototype.step = function() {
      console.log("Doing step " + this.steps[this.stepCount]);
      this[this.steps[this.stepCount]]();
      this.stepCount++;
      if (this.stepCount === this.steps.length) {
        this.stepCount = 0;
      }
      console.log(this);
      if (this.output != null) {
        return this.print();
      }
    };

    return SimplexSolver;

  })();

}).call(this);

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQnJhZGxleVxcQXBwRGF0YVxcUm9hbWluZ1xcbnBtXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1VzZXJzL0JyYWRsZXkvRG9jdW1lbnRzL0dpdEh1Yi9TaW1wbGV4L2xpYi9hcHAuanMiLCJDOi9Vc2Vycy9CcmFkbGV5L0RvY3VtZW50cy9HaXRIdWIvU2ltcGxleC9saWIvaW5wdXQuanMiLCJDOi9Vc2Vycy9CcmFkbGV5L0RvY3VtZW50cy9HaXRIdWIvU2ltcGxleC9saWIvcGFyc2Vycy5qcyIsIkM6L1VzZXJzL0JyYWRsZXkvRG9jdW1lbnRzL0dpdEh1Yi9TaW1wbGV4L2xpYi9zb2x2ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcblxuLyoqXG5cbjEuIEdvYWw6IE1heGltaXplXG4yOiBPYmplY3RpdmU6IDJ4ICsgeSA9IFBcbjM6IHggKyB5ID49MlxuNDogeSA+PSAwXG41OiB4ID49IDBcblxuLS0tLS0+PlxueCB8IHkgfCBzMSB8IHMyIHwgczMgfCBQIHwgQ1xuMSAgIDEgICAtMSAgICAwICAgIDAgICAwICAgMlxuMSAgIDAgICAgMCAgICAtMSAgIDAgICAwICAgMFxuMCAgIDEgICAgMCAgICAwICAgIC0xICAwICAgMFxuLTIgLTEgICAwICAgICAwICAgIDAgICAxICAgMFxuXG5cbnNlbGVjdCBwaXZvdCBjb2x1bW4geCwgYmVjYXVzZSAtMiBpcyBtb3N0IG5lZ2F0aXZlXG5cbmZvciBlYWNoIHJvdzogZGl2aWRlIEMgYnkgdGhlIHBpdm90IGNvbHVtcyBlbnRyeSBmb3IgdGhhdCByb3dcblxuc2VsZWN0IHNtYWxsZXN0IGFzIHRoZSBwaXZvdCByb3dcblxuZGl2aWRlIGJ5IHJlY2Vwcm9jYWxcblxudXNlIHRoaXMgcm93IHRvIG1ha2UgdGhlIHBpdm90IGNvbHVtcyBlbnRyeSAwIGZvciBlYWNoIG90aGVyIHJvd1xuXG5zZWxlY3QgYW5vdGhlciBwaXZvdCB1bmxlc3Mgbm8gbmVnYXRpdmUgaW5kaWNhdG9ycyAoYWxsIGJ1dCBQLEMpXG5cblxuXG5cblxuKlxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFNpbXBsZXhGb3JtZXIsIFNpbXBsZXhTb2x2ZXI7XG5cbiAgU2ltcGxleEZvcm1lciA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcblxuICBTaW1wbGV4U29sdmVyID0gcmVxdWlyZSgnLi9zb2x2ZXInKTtcblxuICB3aW5kb3cuU2ltcGxleCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaW1wbGV4KGRpdikge1xuICAgICAgdmFyIGJ1dHRvbiwgaW5wdXQ7XG4gICAgICBpbnB1dCA9IG5ldyBTaW1wbGV4Rm9ybWVyKFwiXCIgKyBkaXYgKyBcIkZvcm1cIik7XG4gICAgICBidXR0b24gPSBcIlwiICsgZGl2ICsgXCJCdXR0b25cIjtcbiAgICAgICQoXCIjXCIgKyBidXR0b24pLnRleHQoJ1N0YXJ0IFNvbHZlJyk7XG4gICAgICAkKFwiI1wiICsgYnV0dG9uKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvbHZlcjtcbiAgICAgICAgaWYgKGlucHV0Lm91dHB1dE1hdHJpeCAhPSBudWxsKSB7XG4gICAgICAgICAgJChcIiNcIiArIGJ1dHRvbikub2ZmKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coaW5wdXQub3V0cHV0TWF0cml4KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhkaXYpO1xuICAgICAgICAgIHNvbHZlciA9IG5ldyBTaW1wbGV4U29sdmVyKGlucHV0Lm91dHB1dE1hdHJpeCwgZGl2KTtcbiAgICAgICAgICByZXR1cm4gJChcIiNcIiArIGJ1dHRvbikudGV4dCgnU3RlcCBTaW1wbGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBTaW1wbGV4O1xuXG4gIH0pKCk7XG5cblxuICAvKipcbiAgKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKytcbiAgVG8gZGVmaW5lIGEgc2ltcGxleCBtYXRyaXggaXMgZGVmaW5lZFxuICB0aGUgZmlyc3QgbiBjb2x1bW5zIG9mIGEgcm93IGFyZSBmb3IgdGhlIHZhcmlhYmxlc1xuICB0aGUgbmV4dCBuIGNvbHVtcyBvZiBhIHJvdyBhcmUgZm9yIHNsYWNrIHZhcmlhYmxlc1xuICB0aGUgbmV4dCBjb2x1bW4gaXMgZm9yIHRoZSBQIG9mIHRoZSBvYmplY3RpdmUgZnVuY3Rpb25cbiAgdGhlIG5leHQgY29sdW1uIGlzIGZvciB0aGUgY29uc3RyYWludFxuICBcbiAgdG8gbWFrZSBhIHNvbHZlciBhbmQgYXR0YWNoIGl0IHRvIGEgZGl2ICh3aXRoIGEgdW5pcXVlIElEISkgZG8gYXMgZm9sbG93czpcbiAgXG4gIG15U29sdmVyID0gbmV3IFNpbXBsZXhTb2x2ZXIobXlNYXRyaXgsIFwibXlEaXZJRFwiKTtcbiAgXG4gIFxuICAgIFxuICAqXG4gICAqL1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgU2ltcGxleEZvcm1lciwganNlcEFTVCwgbGluZWFyTWF0cml4LFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIGpzZXBBU1QgPSByZXF1aXJlKCcuL3BhcnNlcnMnKS5qc2VwQVNUO1xuXG4gIGxpbmVhck1hdHJpeCA9IHJlcXVpcmUoJy4vcGFyc2VycycpLmxpbmVhck1hdHJpeDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZXhGb3JtZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxleEZvcm1lcihkaXYpIHtcbiAgICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgICAgdGhpcy5vdXRwdXRNYXRyaXggPSBudWxsO1xuICAgICAgdGhpcy5Gb3JtQ29udGV4dCA9IHtcbiAgICAgICAgb2JqRnVuY01lc3NhZ2U6IGNqcy5jb25zdHJhaW50KGZhbHNlKSxcbiAgICAgICAgbmV3Q29uc3RyYWludEZ1bmNNZXNzYWdlOiBjanMuY29uc3RyYWludChmYWxzZSksXG4gICAgICAgIGNvbnN0cmFpbnQ6IGNqcy5hcnJheShbXSksXG4gICAgICAgIG1hdHJpeDogY2pzLmFycmF5KFtdKSxcbiAgICAgICAgb3JkZXI6IGNqcy5hcnJheShbXSlcbiAgICAgIH07XG4gICAgICB3aW5kb3cuZGVidWdDb250ZXh0ID0gdGhpcy5Gb3JtQ29udGV4dDtcbiAgICAgICQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkKFwiI1wiICsgX3RoaXMuZGl2KS5odG1sKGNqcy5jcmVhdGVUZW1wbGF0ZSgkKCcjU2ltcGxleEZvcm0nKSwgX3RoaXMuRm9ybUNvbnRleHQpKTtcbiAgICAgICAgICAkKFwiI25ldy1jb25zdHJhaW50LWFkZFwiKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXMsIHJlc09iamVjdGl2ZTtcbiAgICAgICAgICAgIHJlcyA9IF90aGlzLnZhbGlkYXRlKF90aGlzLkZvcm1Db250ZXh0Lm5ld0NvbnN0cmFpbnRGdW5jLmdldCgpLCAnY29uc3RyYWludCcpO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICBfdGhpcy5Gb3JtQ29udGV4dC5jb25zdHJhaW50LnB1c2gocmVzKTtcbiAgICAgICAgICAgICAgcmVzT2JqZWN0aXZlID0gX3RoaXMudmFsaWRhdGUoX3RoaXMuRm9ybUNvbnRleHQub2JqRnVuYy5nZXQoKSwgJ29iamVjdGl2ZScpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudG9NYXRyaXgocmVzT2JqZWN0aXZlLCBfdGhpcy5Gb3JtQ29udGV4dC5jb25zdHJhaW50LnRvQXJyYXkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNqcy5saXZlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlKF90aGlzLkZvcm1Db250ZXh0Lm5ld0NvbnN0cmFpbnRGdW5jLmdldCgpLCAnY29uc3RyYWludCcpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnZhbGlkYXRlKF90aGlzLkZvcm1Db250ZXh0Lm9iakZ1bmMuZ2V0KCksICdvYmplY3RpdmUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9XG5cbiAgICBTaW1wbGV4Rm9ybWVyLnByb3RvdHlwZS50b01hdHJpeCA9IGZ1bmN0aW9uKG9iamVjdGl2ZSwgY29uc3RyYWludHMpIHtcbiAgICAgIHZhciBjb2wsIG1hdHJpeCwgbWF0cml4Um93LCBvYmplY3RpdmVOYW1lLCBvcmRlciwgcHJlRm9ybSwgcm93LCB2YXJOYW1lLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMztcbiAgICAgIGlmIChvYmplY3RpdmUgJiYgdHlwZW9mIG9iamVjdGl2ZSAhPT0gJ3N0cmluZycgJiYgY29uc3RyYWludHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIG9iamVjdGl2ZU5hbWUgPSBvYmplY3RpdmUucmVzO1xuICAgICAgICBwcmVGb3JtID0gbmV3IGxpbmVhck1hdHJpeChbb2JqZWN0aXZlXSk7XG4gICAgICAgIG9iamVjdGl2ZSA9IHByZUZvcm0ubWF0cml4WzBdO1xuICAgICAgICBvcmRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhck5hbWUgaW4gb2JqZWN0aXZlKSB7XG4gICAgICAgICAgaWYgKHZhck5hbWUgIT09IG9iamVjdGl2ZU5hbWUpIHtcbiAgICAgICAgICAgIG9yZGVyLnB1c2godmFyTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZUZvcm0gPSBuZXcgbGluZWFyTWF0cml4KGNvbnN0cmFpbnRzKTtcbiAgICAgICAgY29uc3RyYWludHMgPSBwcmVGb3JtLm1hdHJpeDtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjb25zdHJhaW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHJvdyA9IGNvbnN0cmFpbnRzW19pXTtcbiAgICAgICAgICBmb3IgKHZhck5hbWUgaW4gcm93KSB7XG4gICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwob3JkZXIsIHZhck5hbWUpIDwgMCAmJiB2YXJOYW1lWzBdICE9PSAnJCcgJiYgdmFyTmFtZSAhPT0gJ2NvbnN0cmFpbnQnKSB7XG4gICAgICAgICAgICAgIG9yZGVyLnB1c2godmFyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGNvbnN0cmFpbnRzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIHJvdyA9IGNvbnN0cmFpbnRzW19qXTtcbiAgICAgICAgICBmb3IgKHZhck5hbWUgaW4gcm93KSB7XG4gICAgICAgICAgICBpZiAodmFyTmFtZVswXSA9PT0gJyQnICYmIF9faW5kZXhPZi5jYWxsKG9yZGVyLCB2YXJOYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgb3JkZXIucHVzaCh2YXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXIucHVzaChvYmplY3RpdmVOYW1lKTtcbiAgICAgICAgb3JkZXIucHVzaCgnY29uc3RyYWludCcpO1xuICAgICAgICBjb25zdHJhaW50cy5wdXNoKG9iamVjdGl2ZSk7XG4gICAgICAgIG1hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBjb25zdHJhaW50cy5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgICAgICByb3cgPSBjb25zdHJhaW50c1tfa107XG4gICAgICAgICAgbWF0cml4Um93ID0gW107XG4gICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gb3JkZXIubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICAgICAgICBjb2wgPSBvcmRlcltfbF07XG4gICAgICAgICAgICBpZiAocm93W2NvbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByb3dbY29sXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXhSb3cucHVzaChyb3dbY29sXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdHJpeC5wdXNoKG1hdHJpeFJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5Gb3JtQ29udGV4dC5vcmRlci5zZXRWYWx1ZShvcmRlcik7XG4gICAgICAgIHRoaXMuRm9ybUNvbnRleHQubWF0cml4LnNldFZhbHVlKG1hdHJpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dE1hdHJpeCA9IG1hdHJpeDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2ltcGxleEZvcm1lci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbih0b1ZhbGlkYXRlLCB0eXBlKSB7XG4gICAgICB2YXIgZSwgcGFyc2UsIHNldCwgdmFsaWRhdGVPYmo7XG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbnN0cmFpbnQnKSB7XG4gICAgICAgIHNldCA9ICduZXdDb25zdHJhaW50RnVuY01lc3NhZ2UnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0aXZlJykge1xuICAgICAgICBzZXQgPSAnb2JqRnVuY01lc3NhZ2UnO1xuICAgICAgfVxuICAgICAgaWYgKHNldCAhPSBudWxsKSB7XG4gICAgICAgIHZhbGlkYXRlT2JqID0ge1xuICAgICAgICAgIHZhbDogdG9WYWxpZGF0ZSxcbiAgICAgICAgICBlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGpzZXAodmFsaWRhdGVPYmoudmFsKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmouZSA9IGUuZGVkc2NyaXB0aW9uO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh2YWxpZGF0ZU9iai5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuRm9ybUNvbnRleHRbc2V0XS5zZXQodmFsaWRhdGVPYmouZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlID0gbmV3IGpzZXBBU1QoanNlcCh2YWxpZGF0ZU9iai52YWwpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICB2YWxpZGF0ZU9iai5lID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT2JqLmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuRm9ybUNvbnRleHRbc2V0XS5zZXQodmFsaWRhdGVPYmouZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoL15bQS16XSskLy50ZXN0KHRoaXMuRm9ybUNvbnRleHQub2JqVmFyLmdldCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkZvcm1Db250ZXh0W3NldF0uc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHByOiBwYXJzZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgb3A6IFwiZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlczogdGhpcy5Gb3JtQ29udGV4dC5vYmpWYXIuZ2V0KClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRm9ybUNvbnRleHRbc2V0XS5zZXQoJ09iamVjdGl2ZSB2YWx1ZSBtdXN0IGEgdmFyaWFibGUgbmFtZSEnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbnN0cmFpbnQnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoL15bXFxkXSskLy50ZXN0KHRoaXMuRm9ybUNvbnRleHQubmV3Q29uc3RyYWludFZhbC5nZXQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Gb3JtQ29udGV4dFtzZXRdLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwcjogcGFyc2Uuc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIG9wOiAkKCcjbmV3Q29uc3RyYWludE9wJykuY2hpbGRyZW4oJzpzZWxlY3RlZCcpLmZpcnN0KCkudmFsKCksXG4gICAgICAgICAgICAgICAgICAgICAgcmVzOiB0aGlzLkZvcm1Db250ZXh0Lm5ld0NvbnN0cmFpbnRWYWwuZ2V0KClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRm9ybUNvbnRleHRbc2V0XS5zZXQoJ0NvbnN0cmFpbnQgdmFsdWUgbXVzdCBiZSBhIG51bWJlciEnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLkZvcm1Db250ZXh0W3NldF0uc2V0KCdTb21ldGhpbmcgd2VudCB3cm9uZycpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU2ltcGxleEZvcm1lcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIganNlcEFTVDtcblxuICBleHBvcnRzLmpzZXBBU1QgPSBqc2VwQVNUID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGpzZXBBU1QoQVNUKSB7XG4gICAgICB0aGlzLnN0cmluZyA9ICcnO1xuICAgICAgdGhpcy50b1N0cmluZyhBU1QpO1xuICAgIH1cblxuICAgIGpzZXBBU1QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oQVNUKSB7XG4gICAgICBpZiAoQVNULnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm91bmRMaXRlcmFsKEFTVCk7XG4gICAgICB9IGVsc2UgaWYgKEFTVC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvdW5kSWRlbnRpZmllcihBU1QpO1xuICAgICAgfSBlbHNlIGlmIChBU1QudHlwZSA9PT0gJ0NvbXBvdW5kJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm91bmRDb21wb3VuZChBU1QpO1xuICAgICAgfSBlbHNlIGlmIChBU1QudHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3VuZEJpbmFyeUV4cHJlc3Npb24oQVNUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFTVCB0eXBlIG5vdCBpbiBbJ0NvbXBvdW5kJywgJ0JpbmFyeUV4cHJlc3Npb24nLCAnSWRlbnRpZmllcicsICdMaXRlcmFsJ10uIFRpcDogMTJ4IHNob3VsZCBiZSB3cml0dGVuIGFzIDEyKHgpXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBqc2VwQVNULnByb3RvdHlwZS5fZm91bmRMaXRlcmFsID0gZnVuY3Rpb24oQVNUKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmcgKz0gQVNULnZhbHVlO1xuICAgIH07XG5cbiAgICBqc2VwQVNULnByb3RvdHlwZS5fZm91bmRJZGVudGlmaWVyID0gZnVuY3Rpb24oQVNUKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmcgKz0gQVNULm5hbWU7XG4gICAgfTtcblxuICAgIGpzZXBBU1QucHJvdG90eXBlLl9mb3VuZENvbXBvdW5kID0gZnVuY3Rpb24oQVNUKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IEFTVC5ib2R5O1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBleHByZXNzaW9uID0gX3JlZltfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy50b1N0cmluZyhleHByZXNzaW9uKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIGpzZXBBU1QucHJvdG90eXBlLl9mb3VuZEJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbihBU1QpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKChfcmVmID0gQVNULm9wZXJhdG9yKSA9PT0gJysnIHx8IF9yZWYgPT09ICctJykge1xuICAgICAgICB0aGlzLnRvU3RyaW5nKEFTVC5sZWZ0KTtcbiAgICAgICAgdGhpcy5zdHJpbmcgKz0gXCIgXCIgKyBBU1Qub3BlcmF0b3IgKyBcIiBcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoQVNULnJpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgZXhwcmVzc2lvbnMgaW4gWycrJywgJy0nXSBhcmUgc3VwcG9ydGVkLiBUaXA6IDEyKnggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgMTIoeClcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBqc2VwQVNUO1xuXG4gIH0pKCk7XG5cbiAgZXhwb3J0cy5saW5lYXJNYXRyaXggPSB3aW5kb3cubGluZWFyTWF0cml4ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGxpbmVhck1hdHJpeChsaW5lYXJBcnIpIHtcblxuICAgICAgLyoqXG4gICAgICAgIGVxdWF0aW9ucyBvZiBsaW5lYXJBcnIgc2hvdWxkIGxvb2sgbGlrZTpcbiAgICAgICAge1xuICAgICAgICAgIGV4cHI6IFNUUklOR1xuICAgICAgICAgIG9wOiAjaW4gWydsdGUnLCAnZ3RlJywgJ2UnXVxuICAgICAgICAgIHJlczogU1RSSU5HIG9yIE51bWJlclxuICAgICAgICB9XG4gICAgICAgIGlmIHRoZSByZXN1bHQgaXMgYSBzdHJpbmcsIG9wIG11c3QgZXF1YWwgJ2UnXG4gICAgICAgIGlmIHRoZSByZXN1bHQgaXMgYSBudW1iZXIgb3AgbXVzdCBlcXVhbCAnbHRlJyBvciAnZ3RlJ1xuICAgICAgXG4gICAgICAqXG4gICAgICAgKi9cbiAgICAgIHZhciBlcXVhdGlvbiwgaSwgX2ksIF9sZW47XG4gICAgICB0aGlzLm1hdHJpeCA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gbGluZWFyQXJyLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICBlcXVhdGlvbiA9IGxpbmVhckFycltpXTtcbiAgICAgICAgdGhpcy5wYXJzZShlcXVhdGlvbiwgaSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluZWFyTWF0cml4LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGVxdWF0aW9uLCBpLCB0b01hdHJpeCkge1xuICAgICAgdmFyIE51bVZhbGlkYXRlLCBOdW1WYXIsIFN0clZhbGlkYXRlLCBtb2RlLCBuZWdhdGl2ZSwgcGFydCwgcmVzLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAodG9NYXRyaXggPT0gbnVsbCkge1xuICAgICAgICB0b01hdHJpeCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgTnVtVmFyID0gL14oXFxkKyk/KFtBLXpdKykkLztcbiAgICAgIFN0clZhbGlkYXRlID0gL15bQS16XSskLztcbiAgICAgIE51bVZhbGlkYXRlID0gL15bXFxkXSskLztcbiAgICAgIHRoaXMubWF0cml4LnB1c2goe30pO1xuICAgICAgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgIGlmIChlcXVhdGlvbi5vcCA9PT0gJ2UnICYmIFN0clZhbGlkYXRlLnRlc3QoZXF1YXRpb24ucmVzKSkge1xuICAgICAgICBtb2RlID0gJ29iamVjdGl2ZSc7XG4gICAgICB9IGVsc2UgaWYgKCgoX3JlZiA9IGVxdWF0aW9uLm9wKSA9PT0gJ2x0ZScgfHwgX3JlZiA9PT0gJ2d0ZScpICYmIE51bVZhbGlkYXRlLnRlc3QoZXF1YXRpb24ucmVzKSkge1xuICAgICAgICBtb2RlID0gJ2NvbnN0cmFpbnQnO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSBlcXVhdGlvbi5leHByLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhcnQgPSBfcmVmMVtfaV07XG4gICAgICAgIHJlcyA9IE51bVZhci5leGVjKHBhcnQpO1xuICAgICAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgICBpZiAocGFydCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnKycpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgocmVzWzFdICE9IG51bGwpICYmIChyZXNbMl0gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnb2JqZWN0aXZlJykge1xuICAgICAgICAgICAgICByZXNbMV0gPSAtcmVzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXRyaXhbaV1bcmVzWzJdXSA9IHBhcnNlRmxvYXQocmVzWzFdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc1sxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2NvbnN0cmFpbnQnKSB7XG4gICAgICAgICAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGVxdWF0aW9uLnJlcyA9ICtyZXNbMV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXF1YXRpb24ucmVzID0gLXJlc1sxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnb2JqZWN0aXZlJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29iamVjdGl2ZSBmdW5jdGlvbiBub3Qgc2ltcGxpZmllZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYXRyaXhbaV1bcmVzWzJdXSA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5tYXRyaXhbaV1bcmVzWzJdXSA9IDE7XG4gICAgICAgICAgICAgIHRoaXMubWF0cml4W2ldW3Jlc1syXV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1vZGUgPT09ICdjb25zdHJhaW50Jykge1xuICAgICAgICBpZiAoZXF1YXRpb24ub3AgPT09ICdsdGUnKSB7XG4gICAgICAgICAgdGhpcy5tYXRyaXhbaV1bXCIkMFwiICsgcmVzWzJdXSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoZXF1YXRpb24ub3AgPT09ICdndGUnKSB7XG4gICAgICAgICAgdGhpcy5tYXRyaXhbaV1bXCIkMFwiICsgcmVzWzJdXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeFtpXVsnY29uc3RyYWludCddID0gcGFyc2VJbnQoZXF1YXRpb24ucmVzKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ29iamVjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4W2ldW2VxdWF0aW9uLnJlc10gPSAxO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gbGluZWFyTWF0cml4O1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gd2luZG93LlNpbXBsZXhTb2x2ZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxleFNvbHZlcihtYXRyaXgsIGRpdikge1xuICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG5cbiAgICAgIC8qKlxuICAgICAgICBtYXRyaXggaXMgYW4gYXJyIG9mIGFyclxuICAgICAgICBhcnJbMF0gcmV0dXJucyB0aGUgZmlyc3Qgcm93XG4gICAgICAgIGFyclswXVswXSByZXR1cm5zIHRoZSBmaXJzdCBlbGVtIGluIGZpcnN0IHJvd1xuICAgICAgKlxuICAgICAgICovXG4gICAgICB0aGlzLnBpdm90Q29sID0gZmFsc2U7XG4gICAgICB0aGlzLnBpdm90Um93ID0gZmFsc2U7XG4gICAgICB0aGlzLnJvd0NvdW50ID0gdGhpcy5tYXRyaXgubGVuZ3RoO1xuICAgICAgdGhpcy5jb2xDb3VudCA9IHRoaXMubWF0cml4WzBdLmxlbmd0aDtcbiAgICAgIHRoaXMuaW5kaWNhdG9yUm93ID0gdGhpcy5yb3dDb3VudCAtIDE7XG4gICAgICB0aGlzLmZpbnNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RlcHMgPSBbJ3NlbGVjdFBpdm90JywgJ3NlbGVjdFBpdm90Um93JywgJ25vcm1hbGl6ZVBpdm90Um93JywgJ3JlZHVjZVBpdm90Q29sdW0nXTtcbiAgICAgIHRoaXMuc3RlcENvdW50ID0gMDtcbiAgICAgIHRoaXMuc3RhcnQgPSB0cnVlO1xuICAgICAgaWYgKGRpdiAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gZGl2O1xuICAgICAgICAkKFwiI1wiICsgZGl2ICsgXCJCdXR0b25cIikub24oXCJjbGlja1wiLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RlcCgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTaW1wbGV4U29sdmVyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHJvdywgX2ksIF9sZW4sIF9yZWY7XG4gICAgICAkKFwiI1wiICsgdGhpcy5vdXRwdXQpLmFwcGVuZChcIjxwcmU+XCIpO1xuICAgICAgX3JlZiA9IHRoaXMubWF0cml4O1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcbiAgICAgICAgcm93ID0gX3JlZltpXTtcbiAgICAgICAgJChcIiNcIiArIHRoaXMub3V0cHV0KS5hcHBlbmQoXCJcIiArIChKU09OLnN0cmluZ2lmeSh0aGlzLm1hdHJpeFtpXSkpICsgXCI8YnIvPlwiKTtcbiAgICAgIH1cbiAgICAgICQoXCIjXCIgKyB0aGlzLm91dHB1dCkuYXBwZW5kKFwiPC9wcmU+XCIpO1xuICAgICAgJChcIiNcIiArIHRoaXMub3V0cHV0KS5hcHBlbmQoXCJQaXZvdENvbDogXCIgKyB0aGlzLnBpdm90Q29sICsgXCI8YnIgLz4gUGl2b3RSb3c6IFwiICsgdGhpcy5waXZvdFJvdyArIFwiPGJyIC8+IEZpbnNoZWQ6IFwiICsgdGhpcy5maW5zaGVkICsgXCI8L3A+XCIpO1xuICAgICAgJChcIiNcIiArIHRoaXMub3V0cHV0KS5hcHBlbmQoXCItLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgIGlmICghdGhpcy5maW5zaGVkKSB7XG4gICAgICAgIHJldHVybiAkKFwiI1wiICsgdGhpcy5vdXRwdXQpLmFwcGVuZChcIjxwPiBTdGVwIFwiICsgdGhpcy5zdGVwc1t0aGlzLnN0ZXBDb3VudF0gKyBcIjpcXG4gPC9wPjxwPlwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2ltcGxleFNvbHZlci5wcm90b3R5cGUuc2VsZWN0UGl2b3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtLCBpLCBtb3N0TmVnYXRpdmUsIHBpdm90Q29sLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmICh0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGl2b3RDb2wgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1vc3ROZWdhdGl2ZSA9IEluZmluaXR5O1xuICAgICAgcGl2b3RDb2wgPSBudWxsO1xuICAgICAgX3JlZiA9IHRoaXMubWF0cml4W3RoaXMuaW5kaWNhdG9yUm93XTtcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW2ldO1xuICAgICAgICBpZiAoaSA8IHRoaXMuY29sQ291bnQgLSAyKSB7XG4gICAgICAgICAgaWYgKGVsZW0gPCBtb3N0TmVnYXRpdmUpIHtcbiAgICAgICAgICAgIG1vc3ROZWdhdGl2ZSA9IGVsZW07XG4gICAgICAgICAgICBwaXZvdENvbCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobW9zdE5lZ2F0aXZlIDwgMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXZvdENvbCA9IHBpdm90Q29sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5zaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5tYXRyaXgpO1xuICAgICAgICAkKFwiI1wiICsgdGhpcy5vdXRwdXQgKyBcIkJ1dHRvblwiKS50ZXh0KCdGaW5zaGVkJyk7XG4gICAgICAgIHJldHVybiAkKFwiI1wiICsgdGhpcy5vdXRwdXQgKyBcIkJ1dHRvblwiKS5vZmYoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2ltcGxleFNvbHZlci5wcm90b3R5cGUuc2VsZWN0UGl2b3RSb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBwaXZvdFJvdywgcm93LCBzbWFsbGVzdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBzbWFsbGVzdCA9IEluZmluaXR5O1xuICAgICAgcGl2b3RSb3cgPSBudWxsO1xuICAgICAgX3JlZiA9IHRoaXMubWF0cml4O1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcbiAgICAgICAgcm93ID0gX3JlZltpXTtcbiAgICAgICAgaWYgKGkgPCB0aGlzLnJvd0NvdW50IC0gMSkge1xuICAgICAgICAgIGlmIChyb3dbdGhpcy5jb2xDb3VudCAtIDFdIC8gcm93W3RoaXMucGl2b3RDb2xdID4gMCkge1xuICAgICAgICAgICAgaWYgKHJvd1t0aGlzLmNvbENvdW50IC0gMV0gLyByb3dbdGhpcy5waXZvdENvbF0gPCBzbWFsbGVzdCkge1xuICAgICAgICAgICAgICBzbWFsbGVzdCA9IHJvd1t0aGlzLmNvbENvdW50IC0gMV0gLyByb3dbdGhpcy5waXZvdENvbF07XG4gICAgICAgICAgICAgIHBpdm90Um93ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGl2b3RSb3cgPSBwaXZvdFJvdztcbiAgICAgIGlmICh0aGlzLnBpdm90Um93ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbnNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTaW1wbGV4U29sdmVyLnByb3RvdHlwZS5ub3JtYWxpemVQaXZvdFJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW0sIGksIHJlY2Vwcm9jYWwsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIHJlY2Vwcm9jYWwgPSAxIC8gdGhpcy5tYXRyaXhbdGhpcy5waXZvdFJvd11bdGhpcy5waXZvdENvbF07XG4gICAgICBfcmVmID0gdGhpcy5tYXRyaXhbdGhpcy5waXZvdFJvd107XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5tYXRyaXhbdGhpcy5waXZvdFJvd11baV0gPSBlbGVtICogcmVjZXByb2NhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFNpbXBsZXhTb2x2ZXIucHJvdG90eXBlLnJlZHVjZVBpdm90Q29sdW0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtLCBpLCBqLCBtdWx0aWJsZSwgcm93LCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gdGhpcy5tYXRyaXg7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcbiAgICAgICAgcm93ID0gX3JlZltpXTtcbiAgICAgICAgaWYgKCEoaSAhPT0gdGhpcy5waXZvdFJvdykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aWJsZSA9IHRoaXMubWF0cml4W2ldW3RoaXMucGl2b3RDb2xdIC8gdGhpcy5tYXRyaXhbdGhpcy5waXZvdFJvd11bdGhpcy5waXZvdENvbF07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYxLCBfcmVzdWx0czE7XG4gICAgICAgICAgX3JlZjEgPSB0aGlzLm1hdHJpeFtpXTtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSBfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBqID0gKytfaikge1xuICAgICAgICAgICAgZWxlbSA9IF9yZWYxW2pdO1xuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godGhpcy5tYXRyaXhbaV1bal0gPSBlbGVtIC0gbXVsdGlibGUgKiB0aGlzLm1hdHJpeFt0aGlzLnBpdm90Um93XVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBTaW1wbGV4U29sdmVyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkRvaW5nIHN0ZXAgXCIgKyB0aGlzLnN0ZXBzW3RoaXMuc3RlcENvdW50XSk7XG4gICAgICB0aGlzW3RoaXMuc3RlcHNbdGhpcy5zdGVwQ291bnRdXSgpO1xuICAgICAgdGhpcy5zdGVwQ291bnQrKztcbiAgICAgIGlmICh0aGlzLnN0ZXBDb3VudCA9PT0gdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdGVwQ291bnQgPSAwO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2codGhpcyk7XG4gICAgICBpZiAodGhpcy5vdXRwdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmludCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU2ltcGxleFNvbHZlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl19
